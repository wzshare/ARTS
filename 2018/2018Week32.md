# Week 32

> August 6 to August 12

## Algorithm：

## Review：

## Tip：

`switch` 里面不能定义对象或变量，否则会出现 `Expected expression` 错误

这是因为如果没有花括号就创建对象的话，对象的作用域是整个 `switch` 语句，但是 `switch` 中每一个 `case` 都有各自相对封闭的空间，也就是 `switch` 中的语法是不允许对象作用域跨域不同 `case`，就是出于这种原因 才会报错 `Expected expression`，解决的办法是把对象创建在一个 `case` 的作用域里，即给这个 `case` 加上花括号。

## Share：

并发编程的三大问题

- 竞态条件（`Race Condition`）：两个或两个以上线程对共享的数据进行读写操作时，最终的数据结果不确定的情况。

```objc
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    for (int i = 0; i < 100000; i++) {
        num += 1;
    }
});

for (int i = 0; i < 100000; i++) {
    num += 1;
}
NSLog(@"%d", num); // num 可能小于200000
```

- 优先倒置（`Priority Inverstion`）：低优先级的任务会因为各种原因先于高优先级的任务执行。

```objc
dispatch_queue_t highPriority = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
dispatch_queue_t lowPriority = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);

dispatch_async(lowPriority, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    for (int i = 0; i < 10; i++) {
        NSLog(@"low: %d", i);
    }
    dispatch_semaphore_signal(semaphore);
});

dispatch_async(highPriority, ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    for (int i = 10; i < 20; i++) {
        NSLog(@"high: %d", i);
    }
    dispatch_semaphore_signal(semaphore);
});
// 因为 semaphore 使得 lowPriority 可能比 highPriority 先执行
```

- 死锁问题（`Dead Lock`）：两个或两个以上的线程，它们之间互相等待彼此停止执行以获得某种资源，但是没有一方会提前退出。

```objc
// Operation 互相依赖
NSOperation *operationA = [[NSOperation alloc] init];
NSOperation *operationB = [[NSOperation alloc] init];
[operationA addDependency:operationB];
[operationB addDependency:operationA];

// 在同一个串行队列中进行异步、同步嵌套
dispatch_queue_t serialQueue = dispatch_queue_create("seriral queue", DISPATCH_QUEUE_SERIAL_INACTIVE);
dispatch_async(serialQueue, ^{
    dispatch_sync(serialQueue, ^{
        
    });
});
```