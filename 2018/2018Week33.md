# Week 33

> August 13 to August 19

## Algorithm：

## Review：

设计模式六大原则：

- 单一职责原则

- 里氏替换原则

- 依赖倒置原则

- 接口隔离原则

- 迪米特法则

- 开闭原则

## Tip：

使用 `dispatch_barrier_sync` 需要注意的一点：

> The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_sync function.

在使用栅栏函数时，使用自定义的并行队列才有意义，如果用的是串行队列或者系统提供的全局并发队列，这个栅栏函数的作用等同于一个 `dispatch_sync` 的作用。

## Share：

> Assigning retained object to weak property/variable; object will be released after assignment.

直接给 `weak` 对象的属性或变量赋值时，对象在赋值后会被立马 `release`，变为 `nil`。

```objc
__weak UIImage *image = [[UIImage alloc] init];
NSLog(@"%@", image); // print null, image = nil
```

或

```objc
@property(nonatomic, weak) UIImage *image;
self.image = [[UIImage alloc] init];
NSLog(@"%@", image); // print null, image = nil
```

正确应该先赋值给一个 `retained` 的变量，然后再弱引用。

```objc
@property(nonatomic, weak) UIImage *image;
UIImage *img = [[UIImage alloc] init]; // img retained
self.image = image; // weak reference img
```