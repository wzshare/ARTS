# Week 33

> August 13 to August 19

## Algorithm：

[Leetcode - Medium] 127. Word Ladder

思路：采用两端 `BFS`，使用两个 `hashset` 分别记录从 `beginWord` 和 `endWord`，每次从较小的一个 `hashset` 开始广度搜索，直到找到路径。

算法复杂度：假设 `wordList` 字符串个数为 `n`，字符串长度为 `l`，最坏情况是遍历所有的字符串，时间复杂度为 `O(n*l)`。

代码 [Word Ladder](https://github.com/wzshare/Leetcode/blob/master/medium/127_Word_Ladder.swift)

## Review：

设计模式六大原则：

- 单一职责原则

- 里氏替换原则

- 依赖倒置原则

- 接口隔离原则

- 迪米特法则

- 开闭原则

## Tip：

使用 `dispatch_barrier_sync` 需要注意的一点：

> The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_sync function.

在使用栅栏函数时，使用自定义的并行队列才有意义，如果用的是串行队列或者系统提供的全局并发队列，这个栅栏函数的作用等同于一个 `dispatch_sync` 的作用。

## Share：

> Assigning retained object to weak property/variable; object will be released after assignment.

直接给 `weak` 对象的属性或变量赋值时，对象在赋值后会被立马 `release`，变为 `nil`。

```objc
__weak UIImage *image = [[UIImage alloc] init];
NSLog(@"%@", image); // print null, image = nil
```

或

```objc
@property(nonatomic, weak) UIImage *image;
self.image = [[UIImage alloc] init];
NSLog(@"%@", image); // print null, image = nil
```

正确应该先赋值给一个 `retained` 的变量，然后再弱引用。

```objc
@property(nonatomic, weak) UIImage *image;
UIImage *img = [[UIImage alloc] init]; // img retained
self.image = image; // weak reference img
```