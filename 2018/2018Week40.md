# Week 40

> October 1 to October 7

## Algorithm：
[Leetcode - Hard] 25. Reverse Nodes in k-Group
```swift
func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {
    if head?.next == nil {
        return head
    }
    let dummy: ListNode? = ListNode(0)
    dummy!.next = head
    var pre = dummy, start = dummy, end = dummy
    while end != nil {
        end = pre
        for _ in 0..<k {
            end = end?.next
            if end == nil {
                return dummy?.next
            }
        }
        for _ in 1..<k {
            start = pre!.next
            pre!.next = start!.next
            start!.next = end!.next
            end!.next = start
        }
        for _ in 0..<k {
            pre = pre!.next
        }
    }
    return dummy!.next
}
```

## Review：


## Tip：
线程休眠：
```objc
sleep(3);

[NSThread sleepForTimeInterval:3];

dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        
    });
```

`sleep()` 函数阻塞的是当前进程。

## Share：

`TableView` 优化

**预排版**

当获取到 `API JSON` 数据后，把每条 `Cell` 需要的数据都在后台线程计算并封装为一个布局对象 `CellLayout`。`CellLayout` 包含所有文本的 `CoreText` 排版结果、`Cell` 内部每个控件的高度、`Cell` 的整体高度。每个 `CellLayout` 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，`TableView` 在请求各个高度函数时，不会消耗任何多余计算量；当把 `CellLayout` 设置到 `Cell` 内部时，`Cell` 内部也不用再计算布局了。

**预渲染**

对于离屏渲染的圆角在后台线程预先渲染为圆形并单独保存到一个 `ImageCache` 中去。

进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView

**异步绘制**
当需要显示内容（比如调用了 `[layer setNeedDisplay]`）时，通过 `delegate` 向 `UIView` 请求一个异步绘制的任务。在异步绘制时，`Layer` 会传递一个 `BOOL(^isCancelled)()` 这样的 `block`，绘制代码可以随时调用该 `block` 判断绘制任务是否已经被取消。尽量快速、提前判断当前绘制任务是否已经被取消，防止滑动速度过快时，绘制任务还没有完成就可能已经被取消了。

**卡顿**

用 `CADisplayLink` 来监视 CPU 的卡顿问题。