# Week 42

> October 15 to October 21

## Algorithm：
[Leetcode - Medium]

## Review：


## Tip：

执行
```
(lldb) po NSHomeDirectory()
``` 
可以找到沙盒文件路径

可以使用
```
(lldb)p (void)instrumentObjcMessageSends(YES)
```

或
```
extern void instrumentObjcMessageSends(BOOL);
instrumentObjcMessageSends(YES);
```

开启消息转发的记录，记录文件放在 `/private/tmp/` 中，文件名为 `msgSends-xxx`。
```
cd /private/tmp/
```

## Share：

`Runtime` 应用
1. 利用关联对象为分类添加属性
```c
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
```

2. 利用 `Method Swizzling` 交换方法
```objc
BOOL didAddMethod = class_addMethod(class, originalSeletor, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
if (didAddMethod) {
    class_replaceMethod(class, swizzledSeletor, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));
} else {
    method_exchangeImplementations(originMethod, swizzledMethod);
}
```

3. 利用 `class_copyIvarList` 实现 `NSCoding` 的自动归档解档
在利用 `NSKeyedArchiver` 归档解档对象的时候，对象 `Model` 需要实现 `NSCoding` 协议，并且要实现 `encodeWithCoder`、`initWithCoder` 两个方法，在这两个方法中要为每个属性进行 `code` 和 `encode`，不然就会 `crash`。

在项目开发过程中，经常会出现 `Model` 中的属性会变更，这个时候总是会忘记去修改对应的属性 `code` 和 `encode`，这里就会导致 `crash`；为了避免这个现象和让 `Model` 中的方法更加简洁可控，这里我们会利用 `class_copyIvarList` 来获取对象中的成员变量列表，然后利用 `KVC` 来 `code` 和 `encode`。实例代码如下：(这里我们将这个通用的代码抽象成宏，这样子在需要的 `Model` 中直接调用就可以了)
```objc
#define PXYNSCodingRuntime_EncodeWithCoder(Class) \
unsigned int outCount = 0;\
Ivar *ivars = class_copyIvarList([Class class], &outCount);\
for (int i = 0; i < outCount; i++) {\
    Ivar ivar = ivars[i];\
    NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];\
    [aCoder encodeObject:[self valueForKey:key] forKey:key];\
}\
free(ivars);\
\

#define PXYNSCodingRuntime_InitWithCoder(Class)\
if (self = [super init]) {\
    unsigned int outCount = 0;\
    Ivar *ivars = class_copyIvarList([Class class], &outCount);\
    for (int i = 0; i < outCount; i++) {\
        Ivar ivar = ivars[i];\
        NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];\
        id value = [aDecoder decodeObjectForKey:key];\
        if (value) {\
            [self setValue:value forKey:key];\
        }\
    }\
    free(ivars);\
}\
return self;\
\

- (void)encodeWithCoder:(NSCoder *)aCoder {
    PXYNSCodingRuntime_EncodeWithCoder(Father)
}
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
    PXYNSCodingRuntime_InitWithCoder(Father)
}
```

4. 利用 `objc_allocateClassPair`、`object_setClass` 等 `API` 来实现 `KVO Block`
在项目中，会经常使用 `KVO` 来监听某个属性的变化。先给出系统调用的方式，添加监听后，在 `observeValueForKeyPath` 方法中处理变化：
```objc
- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;

 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {

 }
 ```
但是在开发过程中，有时候想将代码增加内聚性和在 `observeValueForKeyPath` 减少判断，我们可以通过 `Runtime` 来实现一个 `KVO Block`，这样调用地方即处理消息的地方，代码上比较直观，简单 `API` 如下：
```objc
typedef void(^PXYKVOCompleteBlock)(id observer, NSString *keyPath, id oldValue, id newValue);

/**
 添加 KVO Block
 */
- (void)pxy_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath completeBlock:(PXYKVOCompleteBlock)completeBlock;

/**
 移除 KVO Block
 */
- (void)pxy_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;
```

5. 利用消息转发机制实现多播委托（蹦床模式）
首先，在对象收到无法处理的消息之后，会执行消息转发，消息转发有三个步骤：

调用 `resolveInstanceMethod` 方法。动态方法解析，这里会给类使用 `class_addMethod` 来增加方法的机会。
调用 `forwardingTargetForSelector` 方法，看是否有备用接收者，将消息转发给备用接收者处理。
调用 `methodSignatureForSelector` 和 `forwardInvocation` 方法，进行完成的消息转发。
如果经过上面三个步骤，还不能正确处理消息，程序就会走 `doesNotRecognizeSelector` 方法，`crash` 掉。

蹦床模式：就是把一条消息 “反弹” 到另外一个对象，蹦床一般使用 `forwardInvocation` 来实现。

在项目开发中，事件回调一般使用：`Block`、`Delegate`、`NSNotificationCenter`；但是在多个模块需要监听一个事件的场景：使用通知会将项目变得不可控，因为任何一个地方都可以监听这个通知，在排查问题的时候就会变得异常困难，这个时候我们可以使用多播委托，实现一对多回调。

大致原理：实现一个管理类，将需要回调的对象注册进来，然后将事件消息发送给这个管理类，由于这个管理类是没有实现委托方法的，就不能正常处理这个消息，这个时候就会走消息转发流程；然后我们通过消息转发流程，将消息转发到注册进来的对象中去，这样子就要可以实现我们的多播委托了。
