# Week 47

> November 19 to November 25

## Algorithm：


## Review：


## Tip：

`[[NSNotificationCenter defaultCenter] postNotification:notify]` 是同步的。
如果是在异步线程发送通知，那么接收通知也是在该线程。

```
- (void)asynNotify {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"post: %@", [NSThread currentThread]);
        NSNotification *notify = [NSNotification notificationWithName:@"ASYN" object:nil];
        [[NSNotificationCenter defaultCenter] postNotification:notify];
        NSLog(@"end");
    });
}
// -----------------
- (void)addNotify {
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notifyMain) name:@"ASYN" object:nil];
}
- (void)notifyMain {
    NSLog(@"recive: %@", [NSThread currentThread]);
}
```
输出为：
```
post: <NSThread: 0x10281a040>{number = 2, name = (null)}
recive: <NSThread: 0x10281a040>{number = 2, name = (null)}
end
```

## Share：

`- (Class)class` 方法的实现：
```
- (Class)class {
    return object_getClass(self);
}
```

在 `KVO` 生成的子类中 `class` 方法被重写，返回的是父类来欺骗用户：
```
- (Class)class {
    return class_getSuperclass(object_getClass(self));
}
```